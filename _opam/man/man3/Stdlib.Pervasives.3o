.TH "Stdlib.Pervasives" 3 2019-11-22 OCamldoc "OCaml library"
.SH NAME
Stdlib.Pervasives \- no description
.SH Module
Module   Stdlib.Pervasives
.SH Documentation
.sp
Module
.BI "Pervasives"
 : 
.B (module Stdlib__pervasives)

.sp

.sp

.sp
.sp

.I val raise 
: 
.B exn -> 'a
.sp

.sp

.I val raise_notrace 
: 
.B exn -> 'a
.sp

.sp

.I val invalid_arg 
: 
.B string -> 'a
.sp

.sp

.I val failwith 
: 
.B string -> 'a
.sp

.sp

.I exception Exit 

.sp

.sp

.I val (=) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (<>) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (<) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (>) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (<=) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (>=) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val compare 
: 
.B 'a -> 'a -> int
.sp

.sp

.I val min 
: 
.B 'a -> 'a -> 'a
.sp

.sp

.I val max 
: 
.B 'a -> 'a -> 'a
.sp

.sp

.I val (==) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val (!=) 
: 
.B 'a -> 'a -> bool
.sp

.sp

.I val not 
: 
.B bool -> bool
.sp

.sp

.I val (&&) 
: 
.B bool -> bool -> bool
.sp

.sp

.I val (&) 
: 
.B bool -> bool -> bool
.sp

.sp

.I val (||) 
: 
.B bool -> bool -> bool
.sp

.sp

.I val (or) 
: 
.B bool -> bool -> bool
.sp

.sp

.I val __LOC__ 
: 
.B string
.sp

.sp

.I val __FILE__ 
: 
.B string
.sp

.sp

.I val __LINE__ 
: 
.B int
.sp

.sp

.I val __MODULE__ 
: 
.B string
.sp

.sp

.I val __POS__ 
: 
.B string * int * int * int
.sp

.sp

.I val __LOC_OF__ 
: 
.B 'a -> string * 'a
.sp

.sp

.I val __LINE_OF__ 
: 
.B 'a -> int * 'a
.sp

.sp

.I val __POS_OF__ 
: 
.B 'a -> (string * int * int * int) * 'a
.sp

.sp

.I val (|>) 
: 
.B 'a -> ('a -> 'b) -> 'b
.sp

.sp

.I val (@@) 
: 
.B ('a -> 'b) -> 'a -> 'b
.sp

.sp

.I val (~-) 
: 
.B int -> int
.sp

.sp

.I val (~+) 
: 
.B int -> int
.sp

.sp

.I val succ 
: 
.B int -> int
.sp

.sp

.I val pred 
: 
.B int -> int
.sp

.sp

.I val (+) 
: 
.B int -> int -> int
.sp

.sp

.I val (-) 
: 
.B int -> int -> int
.sp

.sp

.I val ( * ) 
: 
.B int -> int -> int
.sp

.sp

.I val (/) 
: 
.B int -> int -> int
.sp

.sp

.I val (mod) 
: 
.B int -> int -> int
.sp

.sp

.I val abs 
: 
.B int -> int
.sp

.sp

.I val max_int 
: 
.B int
.sp

.sp

.I val min_int 
: 
.B int
.sp

.sp

.I val (land) 
: 
.B int -> int -> int
.sp

.sp

.I val (lor) 
: 
.B int -> int -> int
.sp

.sp

.I val (lxor) 
: 
.B int -> int -> int
.sp

.sp

.I val lnot 
: 
.B int -> int
.sp

.sp

.I val (lsl) 
: 
.B int -> int -> int
.sp

.sp

.I val (lsr) 
: 
.B int -> int -> int
.sp

.sp

.I val (asr) 
: 
.B int -> int -> int
.sp

.sp

.I val (~-.) 
: 
.B float -> float
.sp

.sp

.I val (~+.) 
: 
.B float -> float
.sp

.sp

.I val (+.) 
: 
.B float -> float -> float
.sp

.sp

.I val (-.) 
: 
.B float -> float -> float
.sp

.sp

.I val ( *. ) 
: 
.B float -> float -> float
.sp

.sp

.I val (/.) 
: 
.B float -> float -> float
.sp

.sp

.I val ( ** ) 
: 
.B float -> float -> float
.sp

.sp

.I val sqrt 
: 
.B float -> float
.sp

.sp

.I val exp 
: 
.B float -> float
.sp

.sp

.I val log 
: 
.B float -> float
.sp

.sp

.I val log10 
: 
.B float -> float
.sp

.sp

.I val expm1 
: 
.B float -> float
.sp

.sp

.I val log1p 
: 
.B float -> float
.sp

.sp

.I val cos 
: 
.B float -> float
.sp

.sp

.I val sin 
: 
.B float -> float
.sp

.sp

.I val tan 
: 
.B float -> float
.sp

.sp

.I val acos 
: 
.B float -> float
.sp

.sp

.I val asin 
: 
.B float -> float
.sp

.sp

.I val atan 
: 
.B float -> float
.sp

.sp

.I val atan2 
: 
.B float -> float -> float
.sp

.sp

.I val hypot 
: 
.B float -> float -> float
.sp

.sp

.I val cosh 
: 
.B float -> float
.sp

.sp

.I val sinh 
: 
.B float -> float
.sp

.sp

.I val tanh 
: 
.B float -> float
.sp

.sp

.I val ceil 
: 
.B float -> float
.sp

.sp

.I val floor 
: 
.B float -> float
.sp

.sp

.I val abs_float 
: 
.B float -> float
.sp

.sp

.I val copysign 
: 
.B float -> float -> float
.sp

.sp

.I val mod_float 
: 
.B float -> float -> float
.sp

.sp

.I val frexp 
: 
.B float -> float * int
.sp

.sp

.I val ldexp 
: 
.B float -> int -> float
.sp

.sp

.I val modf 
: 
.B float -> float * float
.sp

.sp

.I val float 
: 
.B int -> float
.sp

.sp

.I val float_of_int 
: 
.B int -> float
.sp

.sp

.I val truncate 
: 
.B float -> int
.sp

.sp

.I val int_of_float 
: 
.B float -> int
.sp

.sp

.I val infinity 
: 
.B float
.sp

.sp

.I val neg_infinity 
: 
.B float
.sp

.sp

.I val nan 
: 
.B float
.sp

.sp

.I val max_float 
: 
.B float
.sp

.sp

.I val min_float 
: 
.B float
.sp

.sp

.I val epsilon_float 
: 
.B float
.sp

.sp
.I type fpclass 
= 
.B fpclass
=
 | FP_normal
 | FP_subnormal
 | FP_zero
 | FP_infinite
 | FP_nan
 
.sp

.sp

.I val classify_float 
: 
.B float -> fpclass
.sp

.sp

.I val (^) 
: 
.B string -> string -> string
.sp

.sp

.I val int_of_char 
: 
.B char -> int
.sp

.sp

.I val char_of_int 
: 
.B int -> char
.sp

.sp

.I val ignore 
: 
.B 'a -> unit
.sp

.sp

.I val string_of_bool 
: 
.B bool -> string
.sp

.sp

.I val bool_of_string 
: 
.B string -> bool
.sp

.sp

.I val bool_of_string_opt 
: 
.B string -> bool option
.sp

.sp

.I val string_of_int 
: 
.B int -> string
.sp

.sp

.I val int_of_string 
: 
.B string -> int
.sp

.sp

.I val int_of_string_opt 
: 
.B string -> int option
.sp

.sp

.I val string_of_float 
: 
.B float -> string
.sp

.sp

.I val float_of_string 
: 
.B string -> float
.sp

.sp

.I val float_of_string_opt 
: 
.B string -> float option
.sp

.sp

.I val fst 
: 
.B 'a * 'b -> 'a
.sp

.sp

.I val snd 
: 
.B 'a * 'b -> 'b
.sp

.sp

.I val (@) 
: 
.B 'a list -> 'a list -> 'a list
.sp

.sp
.I type in_channel 
= 
.B in_channel

.sp

.sp
.I type out_channel 
= 
.B out_channel

.sp

.sp

.I val stdin 
: 
.B in_channel
.sp

.sp

.I val stdout 
: 
.B out_channel
.sp

.sp

.I val stderr 
: 
.B out_channel
.sp

.sp

.I val print_char 
: 
.B char -> unit
.sp

.sp

.I val print_string 
: 
.B string -> unit
.sp

.sp

.I val print_bytes 
: 
.B bytes -> unit
.sp

.sp

.I val print_int 
: 
.B int -> unit
.sp

.sp

.I val print_float 
: 
.B float -> unit
.sp

.sp

.I val print_endline 
: 
.B string -> unit
.sp

.sp

.I val print_newline 
: 
.B unit -> unit
.sp

.sp

.I val prerr_char 
: 
.B char -> unit
.sp

.sp

.I val prerr_string 
: 
.B string -> unit
.sp

.sp

.I val prerr_bytes 
: 
.B bytes -> unit
.sp

.sp

.I val prerr_int 
: 
.B int -> unit
.sp

.sp

.I val prerr_float 
: 
.B float -> unit
.sp

.sp

.I val prerr_endline 
: 
.B string -> unit
.sp

.sp

.I val prerr_newline 
: 
.B unit -> unit
.sp

.sp

.I val read_line 
: 
.B unit -> string
.sp

.sp

.I val read_int 
: 
.B unit -> int
.sp

.sp

.I val read_int_opt 
: 
.B unit -> int option
.sp

.sp

.I val read_float 
: 
.B unit -> float
.sp

.sp

.I val read_float_opt 
: 
.B unit -> float option
.sp

.sp
.I type open_flag 
= 
.B open_flag
=
 | Open_rdonly
 | Open_wronly
 | Open_append
 | Open_creat
 | Open_trunc
 | Open_excl
 | Open_binary
 | Open_text
 | Open_nonblock
 
.sp

.sp

.I val open_out 
: 
.B string -> out_channel
.sp

.sp

.I val open_out_bin 
: 
.B string -> out_channel
.sp

.sp

.I val open_out_gen 
: 
.B open_flag list -> int -> string -> out_channel
.sp

.sp

.I val flush 
: 
.B out_channel -> unit
.sp

.sp

.I val flush_all 
: 
.B unit -> unit
.sp

.sp

.I val output_char 
: 
.B out_channel -> char -> unit
.sp

.sp

.I val output_string 
: 
.B out_channel -> string -> unit
.sp

.sp

.I val output_bytes 
: 
.B out_channel -> bytes -> unit
.sp

.sp

.I val output 
: 
.B out_channel -> bytes -> int -> int -> unit
.sp

.sp

.I val output_substring 
: 
.B out_channel -> string -> int -> int -> unit
.sp

.sp

.I val output_byte 
: 
.B out_channel -> int -> unit
.sp

.sp

.I val output_binary_int 
: 
.B out_channel -> int -> unit
.sp

.sp

.I val output_value 
: 
.B out_channel -> 'a -> unit
.sp

.sp

.I val seek_out 
: 
.B out_channel -> int -> unit
.sp

.sp

.I val pos_out 
: 
.B out_channel -> int
.sp

.sp

.I val out_channel_length 
: 
.B out_channel -> int
.sp

.sp

.I val close_out 
: 
.B out_channel -> unit
.sp

.sp

.I val close_out_noerr 
: 
.B out_channel -> unit
.sp

.sp

.I val set_binary_mode_out 
: 
.B out_channel -> bool -> unit
.sp

.sp

.I val open_in 
: 
.B string -> in_channel
.sp

.sp

.I val open_in_bin 
: 
.B string -> in_channel
.sp

.sp

.I val open_in_gen 
: 
.B open_flag list -> int -> string -> in_channel
.sp

.sp

.I val input_char 
: 
.B in_channel -> char
.sp

.sp

.I val input_line 
: 
.B in_channel -> string
.sp

.sp

.I val input 
: 
.B in_channel -> bytes -> int -> int -> int
.sp

.sp

.I val really_input 
: 
.B in_channel -> bytes -> int -> int -> unit
.sp

.sp

.I val really_input_string 
: 
.B in_channel -> int -> string
.sp

.sp

.I val input_byte 
: 
.B in_channel -> int
.sp

.sp

.I val input_binary_int 
: 
.B in_channel -> int
.sp

.sp

.I val input_value 
: 
.B in_channel -> 'a
.sp

.sp

.I val seek_in 
: 
.B in_channel -> int -> unit
.sp

.sp

.I val pos_in 
: 
.B in_channel -> int
.sp

.sp

.I val in_channel_length 
: 
.B in_channel -> int
.sp

.sp

.I val close_in 
: 
.B in_channel -> unit
.sp

.sp

.I val close_in_noerr 
: 
.B in_channel -> unit
.sp

.sp

.I val set_binary_mode_in 
: 
.B in_channel -> bool -> unit
.sp

.sp
.I module LargeFile : 
.B (module LargeFile)

.sp

.sp
.I type 
.B 'a
.I ref 
= 
.B 'a ref
= {

.B mutable 
contents : 
.B 'a
;
 }

.sp

.sp

.I val ref 
: 
.B 'a -> 'a ref
.sp

.sp

.I val (!) 
: 
.B 'a ref -> 'a
.sp

.sp

.I val (:=) 
: 
.B 'a ref -> 'a -> unit
.sp

.sp

.I val incr 
: 
.B int ref -> unit
.sp

.sp

.I val decr 
: 
.B int ref -> unit
.sp

.sp
.I type 
.B ('a, 'b)
.I result 
= 
.B ('a, 'b) result
=
 | Ok
.B of 
.B 'a
 | Error
.B of 
.B 'b
 
.sp

.sp
.I type 
.B ('a, 'b, 'c, 'd, 'e, 'f)
.I format6 
= 
.B ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6

.sp

.sp
.I type 
.B ('a, 'b, 'c, 'd)
.I format4 
= 
.B ('a, 'b, 'c, 'c, 'c, 'd) format6

.sp

.sp
.I type 
.B ('a, 'b, 'c)
.I format 
= 
.B ('a, 'b, 'c, 'c) format4

.sp

.sp

.I val string_of_format 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
.sp

.sp

.I val format_of_string 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6
.sp

.sp

.I val (^^) 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   ('f, 'b, 'c, 'e, 'g, 'h) format6 ->
.B   ('a, 'b, 'c, 'd, 'g, 'h) format6
.sp

.sp

.I val exit 
: 
.B int -> 'a
.sp

.sp

.I val at_exit 
: 
.B (unit -> unit) -> unit
.sp

.sp

.I val valid_float_lexem 
: 
.B string -> string
.sp

.sp

.I val do_at_exit 
: 
.B unit -> unit
.sp

.sp
