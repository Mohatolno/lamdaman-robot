.TH "Stdlib" 3 2019-11-22 OCamldoc "OCaml library"
.SH NAME
Stdlib \- The OCaml Standard library.
.SH Module
Module   Stdlib
.SH Documentation
.sp
Module
.BI "Stdlib"
 : 
.B sig  end

.sp
The OCaml Standard library\&.
.sp
This module is automatically opened at the beginning of each
compilation\&. All components of this module can therefore be
referred by their short name, without prefixing them by 
.B Stdlib
\&.
.sp
It particular, it provides the basic operations over the built\-in
types (numbers, booleans, byte sequences, strings, exceptions,
references, lists, arrays, input\-output channels, \&.\&.\&.) and the
.B modules
\&.

.sp

.sp
.sp

.PP
.SS Exceptions

.PP

.I val raise 
: 
.B exn -> 'a
.sp
Raise the given exception value

.sp

.I val raise_notrace 
: 
.B exn -> 'a
.sp
A faster version 
.B raise
which does not record the backtrace\&.

.sp
.B "Since"
4.02.0

.sp

.I val invalid_arg 
: 
.B string -> 'a
.sp
Raise exception 
.B Invalid_argument
with the given string\&.

.sp

.I val failwith 
: 
.B string -> 'a
.sp
Raise exception 
.B Failure
with the given string\&.

.sp

.I exception Exit 

.sp
The 
.B Exit
exception is not raised by any library function\&.  It is
provided for use in your programs\&.

.sp

.I exception Match_failure 
.B of 
.B (string * int * int)

.sp
Exception raised when none of the cases of a pattern\-matching
apply\&. The arguments are the location of the match keyword in the
source code (file name, line number, column number)\&.

.sp

.I exception Assert_failure 
.B of 
.B (string * int * int)

.sp
Exception raised when an assertion fails\&. The arguments are the
location of the assert keyword in the source code (file name, line
number, column number)\&.

.sp

.I exception Invalid_argument 
.B of 
.B string

.sp
Exception raised by library functions to signal that the given
arguments do not make sense\&. The string gives some information to
the programmer\&. As a general rule, this exception should not be
caught, it denotes a programming error and the code should be
modified not to trigger it\&.

.sp

.I exception Failure 
.B of 
.B string

.sp
Exception raised by library functions to signal that they are
undefined on the given arguments\&. The string is meant to give some
information to the programmer; you must not pattern match on the
string literal because it may change in future versions (use
Failure _ instead)\&.

.sp

.I exception Not_found 

.sp
Exception raised by search functions when the desired object could
not be found\&.

.sp

.I exception Out_of_memory 

.sp
Exception raised by the garbage collector when there is
insufficient memory to complete the computation\&.

.sp

.I exception Stack_overflow 

.sp
Exception raised by the bytecode interpreter when the evaluation
stack reaches its maximal size\&. This often indicates infinite or
excessively deep recursion in the user\&'s program\&. (Not fully
implemented by the native\-code compiler\&.)

.sp

.I exception Sys_error 
.B of 
.B string

.sp
Exception raised by the input/output functions to report an
operating system error\&. The string is meant to give some
information to the programmer; you must not pattern match on the
string literal because it may change in future versions (use
Sys_error _ instead)\&.

.sp

.I exception End_of_file 

.sp
Exception raised by input functions to signal that the end of file
has been reached\&.

.sp

.I exception Division_by_zero 

.sp
Exception raised by integer division and remainder operations when
their second argument is zero\&.

.sp

.I exception Sys_blocked_io 

.sp
A special case of Sys_error raised when no I/O is possible on a
non\-blocking I/O channel\&.

.sp

.I exception Undefined_recursive_module 
.B of 
.B (string * int * int)

.sp
Exception raised when an ill\-founded recursive module definition
is evaluated\&. The arguments are the location of the definition in
the source code (file name, line number, column number)\&.

.sp

.PP
.SS Comparisons

.PP

.I val (=) 
: 
.B 'a -> 'a -> bool
.sp

.B e1 = e2
tests for structural equality of 
.B e1
and 
.B e2
\&.
Mutable structures (e\&.g\&. references and arrays) are equal
if and only if their current contents are structurally equal,
even if the two mutable objects are not the same physical object\&.
Equality between functional values raises 
.B Invalid_argument
\&.
Equality between cyclic data structures may not terminate\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (<>) 
: 
.B 'a -> 'a -> bool
.sp
Negation of 
.B (=)
\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (<) 
: 
.B 'a -> 'a -> bool
.sp
See 
.B (>=)
\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (>) 
: 
.B 'a -> 'a -> bool
.sp
See 
.B (>=)
\&.
Left\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.I val (<=) 
: 
.B 'a -> 'a -> bool
.sp
See 
.B (>=)
\&.
Left\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.I val (>=) 
: 
.B 'a -> 'a -> bool
.sp
Structural ordering functions\&. These functions coincide with
the usual orderings over integers, characters, strings, byte sequences
and floating\-point numbers, and extend them to a
total ordering over all types\&.
The ordering is compatible with 
.B ( = )
\&. As in the case
of 
.B ( = )
, mutable structures are compared by contents\&.
Comparison between functional values raises 
.B Invalid_argument
\&.
Comparison between cyclic structures may not terminate\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val compare 
: 
.B 'a -> 'a -> int
.sp

.B compare x y
returns 
.B 0
if 
.B x
is equal to 
.B y
,
a negative integer if 
.B x
is less than 
.B y
, and a positive integer
if 
.B x
is greater than 
.B y
\&.  The ordering implemented by 
.B compare
is compatible with the comparison predicates 
.B =
, 
.B <
and 
.B >
defined above,  with one difference on the treatment of the float value
.B nan
\&.  Namely, the comparison predicates treat 
.B nan
as different from any other float value, including itself;
while 
.B compare
treats 
.B nan
as equal to itself and less than any
other float value\&.  This treatment of 
.B nan
ensures that 
.B compare
defines a total ordering relation\&.
.sp

.B compare
applied to functional values may raise 
.B Invalid_argument
\&.
.B compare
applied to cyclic structures may not terminate\&.
.sp
The 
.B compare
function can be used as the comparison function
required by the 
.B Set\&.Make
and 
.B Map\&.Make
functors, as well as
the 
.B List\&.sort
and 
.B Array\&.sort
functions\&.

.sp

.I val min 
: 
.B 'a -> 'a -> 'a
.sp
Return the smaller of the two arguments\&.
The result is unspecified if one of the arguments contains
the float value 
.B nan
\&.

.sp

.I val max 
: 
.B 'a -> 'a -> 'a
.sp
Return the greater of the two arguments\&.
The result is unspecified if one of the arguments contains
the float value 
.B nan
\&.

.sp

.I val (==) 
: 
.B 'a -> 'a -> bool
.sp

.B e1 == e2
tests for physical equality of 
.B e1
and 
.B e2
\&.
On mutable types such as references, arrays, byte sequences, records with
mutable fields and objects with mutable instance variables,
.B e1 == e2
is true if and only if physical modification of 
.B e1
also affects 
.B e2
\&.
On non\-mutable types, the behavior of 
.B ( == )
is
implementation\-dependent; however, it is guaranteed that
.B e1 == e2
implies 
.B compare e1 e2 = 0
\&.
Left\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.I val (!=) 
: 
.B 'a -> 'a -> bool
.sp
Negation of 
.B (==)
\&.
Left\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Boolean operations

.PP

.I val not 
: 
.B bool -> bool
.sp
The boolean negation\&.

.sp

.I val (&&) 
: 
.B bool -> bool -> bool
.sp
The boolean \&'and\&'\&. Evaluation is sequential, left\-to\-right:
in 
.B e1 && e2
, 
.B e1
is evaluated first, and if it returns 
.B false
,
.B e2
is not evaluated at all\&.
Right\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.I val (&) 
: 
.B bool -> bool -> bool
.sp
.B "Deprecated."

.B (&&)
should be used instead\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (||) 
: 
.B bool -> bool -> bool
.sp
The boolean \&'or\&'\&. Evaluation is sequential, left\-to\-right:
in 
.B e1 || e2
, 
.B e1
is evaluated first, and if it returns 
.B true
,
.B e2
is not evaluated at all\&.
Right\-associative operator,  see 
.B Ocaml_operators
for more information\&.

.sp

.I val (or) 
: 
.B bool -> bool -> bool
.sp
.B "Deprecated."

.B (||)
should be used instead\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Debugging

.PP

.I val __LOC__ 
: 
.B string
.sp

.B __LOC__
returns the location at which this expression appears in
the file currently being parsed by the compiler, with the standard
error format of OCaml: "File %S, line %d, characters %d\-%d"\&.

.sp
.B "Since"
4.02.0

.sp

.I val __FILE__ 
: 
.B string
.sp

.B __FILE__
returns the name of the file currently being
parsed by the compiler\&.

.sp
.B "Since"
4.02.0

.sp

.I val __LINE__ 
: 
.B int
.sp

.B __LINE__
returns the line number at which this expression
appears in the file currently being parsed by the compiler\&.

.sp
.B "Since"
4.02.0

.sp

.I val __MODULE__ 
: 
.B string
.sp

.B __MODULE__
returns the module name of the file being
parsed by the compiler\&.

.sp
.B "Since"
4.02.0

.sp

.I val __POS__ 
: 
.B string * int * int * int
.sp

.B __POS__
returns a tuple 
.B (file,lnum,cnum,enum)
, corresponding
to the location at which this expression appears in the file
currently being parsed by the compiler\&. 
.B file
is the current
filename, 
.B lnum
the line number, 
.B cnum
the character position in
the line and 
.B enum
the last character position in the line\&.

.sp
.B "Since"
4.02.0

.sp

.I val __LOC_OF__ 
: 
.B 'a -> string * 'a
.sp

.B __LOC_OF__ expr
returns a pair 
.B (loc, expr)
where 
.B loc
is the
location of 
.B expr
in the file currently being parsed by the
compiler, with the standard error format of OCaml: "File %S, line
%d, characters %d\-%d"\&.

.sp
.B "Since"
4.02.0

.sp

.I val __LINE_OF__ 
: 
.B 'a -> int * 'a
.sp

.B __LINE_OF__ expr
returns a pair 
.B (line, expr)
, where 
.B line
is the
line number at which the expression 
.B expr
appears in the file
currently being parsed by the compiler\&.

.sp
.B "Since"
4.02.0

.sp

.I val __POS_OF__ 
: 
.B 'a -> (string * int * int * int) * 'a
.sp

.B __POS_OF__ expr
returns a pair 
.B (loc,expr)
, where 
.B loc
is a
tuple 
.B (file,lnum,cnum,enum)
corresponding to the location at
which the expression 
.B expr
appears in the file currently being
parsed by the compiler\&. 
.B file
is the current filename, 
.B lnum
the
line number, 
.B cnum
the character position in the line and 
.B enum
the last character position in the line\&.

.sp
.B "Since"
4.02.0

.sp

.PP
.SS Composition operators

.PP

.I val (|>) 
: 
.B 'a -> ('a -> 'b) -> 'b
.sp
Reverse\-application operator: 
.B x |> f |> g
is exactly equivalent
to 
.B g (f (x))
\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp
.B "Since"
4.01

.sp

.I val (@@) 
: 
.B ('a -> 'b) -> 'a -> 'b
.sp
Application operator: 
.B g @@ f @@ x
is exactly equivalent to
.B g (f (x))
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp
.B "Since"
4.01

.sp

.PP
.SS Integer arithmetic

.PP

.PP
Integers are 
.B Sys\&.int_size
bits wide\&.
All operations are taken modulo 2^
.B Sys\&.int_size
\&.
They do not fail on overflow\&.
.PP

.I val (~-) 
: 
.B int -> int
.sp
Unary negation\&. You can also write 
.B \- e
instead of 
.B ~\- e
\&.
Unary operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (~+) 
: 
.B int -> int
.sp
Unary addition\&. You can also write 
.B + e
instead of 
.B ~+ e
\&.
Unary operator, see 
.B Ocaml_operators
for more information\&.

.sp
.B "Since"
3.12.0

.sp

.I val succ 
: 
.B int -> int
.sp

.B succ x
is 
.B x + 1
\&.

.sp

.I val pred 
: 
.B int -> int
.sp

.B pred x
is 
.B x \- 1
\&.

.sp

.I val (+) 
: 
.B int -> int -> int
.sp
Integer addition\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (-) 
: 
.B int -> int -> int
.sp
Integer subtraction\&.
Left\-associative operator, , see 
.B Ocaml_operators
for more information\&.

.sp

.I val ( * ) 
: 
.B int -> int -> int
.sp
Integer multiplication\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (/) 
: 
.B int -> int -> int
.sp
Integer division\&.
Raise 
.B Division_by_zero
if the second argument is 0\&.
Integer division rounds the real quotient of its arguments towards zero\&.
More precisely, if 
.B x >= 0
and 
.B y > 0
, 
.B x / y
is the greatest integer
less than or equal to the real quotient of 
.B x
by 
.B y
\&.  Moreover,
.B (\- x) / y = x / (\- y) = \- (x / y)
\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (mod) 
: 
.B int -> int -> int
.sp
Integer remainder\&.  If 
.B y
is not zero, the result
of 
.B x mod y
satisfies the following properties:
.B x = (x / y) * y + x mod y
and
.B abs(x mod y) <= abs(y) \- 1
\&.
If 
.B y = 0
, 
.B x mod y
raises 
.B Division_by_zero
\&.
Note that 
.B x mod y
is negative only if 
.B x < 0
\&.
Raise 
.B Division_by_zero
if 
.B y
is zero\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val abs 
: 
.B int -> int
.sp
Return the absolute value of the argument\&.  Note that this may be
negative if the argument is 
.B min_int
\&.

.sp

.I val max_int 
: 
.B int
.sp
The greatest representable integer\&.

.sp

.I val min_int 
: 
.B int
.sp
The smallest representable integer\&.

.sp

.PP
.SS Bitwise operations

.PP

.I val (land) 
: 
.B int -> int -> int
.sp
Bitwise logical and\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (lor) 
: 
.B int -> int -> int
.sp
Bitwise logical or\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (lxor) 
: 
.B int -> int -> int
.sp
Bitwise logical exclusive or\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val lnot 
: 
.B int -> int
.sp
Bitwise logical negation\&.

.sp

.I val (lsl) 
: 
.B int -> int -> int
.sp

.B n lsl m
shifts 
.B n
to the left by 
.B m
bits\&.
The result is unspecified if 
.B m < 0
or 
.B m > Sys\&.int_size
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (lsr) 
: 
.B int -> int -> int
.sp

.B n lsr m
shifts 
.B n
to the right by 
.B m
bits\&.
This is a logical shift: zeroes are inserted regardless of
the sign of 
.B n
\&.
The result is unspecified if 
.B m < 0
or 
.B m > Sys\&.int_size
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (asr) 
: 
.B int -> int -> int
.sp

.B n asr m
shifts 
.B n
to the right by 
.B m
bits\&.
This is an arithmetic shift: the sign bit of 
.B n
is replicated\&.
The result is unspecified if 
.B m < 0
or 
.B m > Sys\&.int_size
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Floating-point arithmetic
.sp
OCaml\&'s floating\-point numbers follow the
IEEE 754 standard, using double precision (64 bits) numbers\&.
Floating\-point operations never raise an exception on overflow,
underflow, division by zero, etc\&.  Instead, special IEEE numbers
are returned as appropriate, such as 
.B infinity
for 
.B 1\&.0 /\&. 0\&.0
,
.B neg_infinity
for 
.B \-1\&.0 /\&. 0\&.0
, and 
.B nan
(\&'not a number\&')
for 
.B 0\&.0 /\&. 0\&.0
\&.  These special numbers then propagate through
floating\-point computations as expected: for instance,
.B 1\&.0 /\&. infinity
is 
.B 0\&.0
, and any arithmetic operation with 
.B nan
as argument returns 
.B nan
as result\&.
.PP

.I val (~-.) 
: 
.B float -> float
.sp
Unary negation\&. You can also write 
.B \-\&. e
instead of 
.B ~\-\&. e
\&.
Unary operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (~+.) 
: 
.B float -> float
.sp
Unary addition\&. You can also write 
.B +\&. e
instead of 
.B ~+\&. e
\&.
Unary operator, see 
.B Ocaml_operators
for more information\&.

.sp
.B "Since"
3.12.0

.sp

.I val (+.) 
: 
.B float -> float -> float
.sp
Floating\-point addition\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (-.) 
: 
.B float -> float -> float
.sp
Floating\-point subtraction\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val ( *. ) 
: 
.B float -> float -> float
.sp
Floating\-point multiplication\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (/.) 
: 
.B float -> float -> float
.sp
Floating\-point division\&.
Left\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val ( ** ) 
: 
.B float -> float -> float
.sp
Exponentiation\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val sqrt 
: 
.B float -> float
.sp
Square root\&.

.sp

.I val exp 
: 
.B float -> float
.sp
Exponential\&.

.sp

.I val log 
: 
.B float -> float
.sp
Natural logarithm\&.

.sp

.I val log10 
: 
.B float -> float
.sp
Base 10 logarithm\&.

.sp

.I val expm1 
: 
.B float -> float
.sp

.B expm1 x
computes 
.B exp x \-\&. 1\&.0
, giving numerically\-accurate results
even if 
.B x
is close to 
.B 0\&.0
\&.

.sp
.B "Since"
3.12.0

.sp

.I val log1p 
: 
.B float -> float
.sp

.B log1p x
computes 
.B log(1\&.0 +\&. x)
(natural logarithm),
giving numerically\-accurate results even if 
.B x
is close to 
.B 0\&.0
\&.

.sp
.B "Since"
3.12.0

.sp

.I val cos 
: 
.B float -> float
.sp
Cosine\&.  Argument is in radians\&.

.sp

.I val sin 
: 
.B float -> float
.sp
Sine\&.  Argument is in radians\&.

.sp

.I val tan 
: 
.B float -> float
.sp
Tangent\&.  Argument is in radians\&.

.sp

.I val acos 
: 
.B float -> float
.sp
Arc cosine\&.  The argument must fall within the range 
.B [\-1\&.0, 1\&.0]
\&.
Result is in radians and is between 
.B 0\&.0
and 
.B pi
\&.

.sp

.I val asin 
: 
.B float -> float
.sp
Arc sine\&.  The argument must fall within the range 
.B [\-1\&.0, 1\&.0]
\&.
Result is in radians and is between 
.B \-pi/2
and 
.B pi/2
\&.

.sp

.I val atan 
: 
.B float -> float
.sp
Arc tangent\&.
Result is in radians and is between 
.B \-pi/2
and 
.B pi/2
\&.

.sp

.I val atan2 
: 
.B float -> float -> float
.sp

.B atan2 y x
returns the arc tangent of 
.B y /\&. x
\&.  The signs of 
.B x
and 
.B y
are used to determine the quadrant of the result\&.
Result is in radians and is between 
.B \-pi
and 
.B pi
\&.

.sp

.I val hypot 
: 
.B float -> float -> float
.sp

.B hypot x y
returns 
.B sqrt(x *\&. x + y *\&. y)
, that is, the length
of the hypotenuse of a right\-angled triangle with sides of length
.B x
and 
.B y
, or, equivalently, the distance of the point 
.B (x,y)
to origin\&.  If one of 
.B x
or 
.B y
is infinite, returns 
.B infinity
even if the other is 
.B nan
\&.

.sp
.B "Since"
4.00.0

.sp

.I val cosh 
: 
.B float -> float
.sp
Hyperbolic cosine\&.  Argument is in radians\&.

.sp

.I val sinh 
: 
.B float -> float
.sp
Hyperbolic sine\&.  Argument is in radians\&.

.sp

.I val tanh 
: 
.B float -> float
.sp
Hyperbolic tangent\&.  Argument is in radians\&.

.sp

.I val ceil 
: 
.B float -> float
.sp
Round above to an integer value\&.
.B ceil f
returns the least integer value greater than or equal to 
.B f
\&.
The result is returned as a float\&.

.sp

.I val floor 
: 
.B float -> float
.sp
Round below to an integer value\&.
.B floor f
returns the greatest integer value less than or
equal to 
.B f
\&.
The result is returned as a float\&.

.sp

.I val abs_float 
: 
.B float -> float
.sp

.B abs_float f
returns the absolute value of 
.B f
\&.

.sp

.I val copysign 
: 
.B float -> float -> float
.sp

.B copysign x y
returns a float whose absolute value is that of 
.B x
and whose sign is that of 
.B y
\&.  If 
.B x
is 
.B nan
, returns 
.B nan
\&.
If 
.B y
is 
.B nan
, returns either 
.B x
or 
.B \-\&. x
, but it is not
specified which\&.

.sp
.B "Since"
4.00.0

.sp

.I val mod_float 
: 
.B float -> float -> float
.sp

.B mod_float a b
returns the remainder of 
.B a
with respect to
.B b
\&.  The returned value is 
.B a \-\&. n *\&. b
, where 
.B n
is the quotient 
.B a /\&. b
rounded towards zero to an integer\&.

.sp

.I val frexp 
: 
.B float -> float * int
.sp

.B frexp f
returns the pair of the significant
and the exponent of 
.B f
\&.  When 
.B f
is zero, the
significant 
.B x
and the exponent 
.B n
of 
.B f
are equal to
zero\&.  When 
.B f
is non\-zero, they are defined by
.B f = x *\&. 2 ** n
and 
.B 0\&.5 <= x < 1\&.0
\&.

.sp

.I val ldexp 
: 
.B float -> int -> float
.sp

.B ldexp x n
returns 
.B x *\&. 2 ** n
\&.

.sp

.I val modf 
: 
.B float -> float * float
.sp

.B modf f
returns the pair of the fractional and integral
part of 
.B f
\&.

.sp

.I val float 
: 
.B int -> float
.sp
Same as 
.B float_of_int
\&.

.sp

.I val float_of_int 
: 
.B int -> float
.sp
Convert an integer to floating\-point\&.

.sp

.I val truncate 
: 
.B float -> int
.sp
Same as 
.B int_of_float
\&.

.sp

.I val int_of_float 
: 
.B float -> int
.sp
Truncate the given floating\-point number to an integer\&.
The result is unspecified if the argument is 
.B nan
or falls outside the
range of representable integers\&.

.sp

.I val infinity 
: 
.B float
.sp
Positive infinity\&.

.sp

.I val neg_infinity 
: 
.B float
.sp
Negative infinity\&.

.sp

.I val nan 
: 
.B float
.sp
A special floating\-point value denoting the result of an
undefined operation such as 
.B 0\&.0 /\&. 0\&.0
\&.  Stands for
\&'not a number\&'\&.  Any floating\-point operation with 
.B nan
as
argument returns 
.B nan
as result\&.  As for floating\-point comparisons,
.B =
, 
.B <
, 
.B <=
, 
.B >
and 
.B >=
return 
.B false
and 
.B <>
returns 
.B true
if one or both of their arguments is 
.B nan
\&.

.sp

.I val max_float 
: 
.B float
.sp
The largest positive finite value of type 
.B float
\&.

.sp

.I val min_float 
: 
.B float
.sp
The smallest positive, non\-zero, non\-denormalized value of type 
.B float
\&.

.sp

.I val epsilon_float 
: 
.B float
.sp
The difference between 
.B 1\&.0
and the smallest exactly representable
floating\-point number greater than 
.B 1\&.0
\&.

.sp
.I type fpclass 
=
 | FP_normal  (* Normal number, none of the below
 *)
 | FP_subnormal  (* Number very close to 0\&.0, has reduced precision
 *)
 | FP_zero  (* Number is 0\&.0 or \-0\&.0
 *)
 | FP_infinite  (* Number is positive or negative infinity
 *)
 | FP_nan  (* Not a number: result of an undefined operation
 *)
 
.sp
The five classes of floating\-point numbers, as determined by
the 
.B classify_float
function\&.

.sp

.I val classify_float 
: 
.B float -> fpclass
.sp
Return the class of the given floating\-point number:
normal, subnormal, zero, infinite, or not a number\&.

.sp

.PP
.SS String operations
.sp
More string operations are provided in module 
.B String
\&.
.PP

.I val (^) 
: 
.B string -> string -> string
.sp
String concatenation\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Character operations
.sp
More character operations are provided in module 
.B Char
\&.
.PP

.I val int_of_char 
: 
.B char -> int
.sp
Return the ASCII code of the argument\&.

.sp

.I val char_of_int 
: 
.B int -> char
.sp
Return the character with the given ASCII code\&.
Raise 
.B Invalid_argument "char_of_int"
if the argument is
outside the range 0\-\-255\&.

.sp

.PP
.SS Unit operations

.PP

.I val ignore 
: 
.B 'a -> unit
.sp
Discard the value of its argument and return 
.B ()
\&.
For instance, 
.B ignore(f x)
discards the result of
the side\-effecting function 
.B f
\&.  It is equivalent to
.B f x; ()
, except that the latter may generate a
compiler warning; writing 
.B ignore(f x)
instead
avoids the warning\&.

.sp

.PP
.SS String conversion functions

.PP

.I val string_of_bool 
: 
.B bool -> string
.sp
Return the string representation of a boolean\&. As the returned values
may be shared, the user should not modify them directly\&.

.sp

.I val bool_of_string_opt 
: 
.B string -> bool option
.sp
Convert the given string to a boolean\&.
.sp
Return 
.B None
if the string is not 
.B "true"
or 
.B "false"
\&.

.sp
.B "Since"
4.05

.sp

.I val bool_of_string 
: 
.B string -> bool
.sp
Same as 
.B bool_of_string_opt
, but raise
.B Invalid_argument "bool_of_string"
instead of returning 
.B None
\&.

.sp

.I val string_of_int 
: 
.B int -> string
.sp
Return the string representation of an integer, in decimal\&.

.sp

.I val int_of_string_opt 
: 
.B string -> int option
.sp
Convert the given string to an integer\&.
The string is read in decimal (by default, or if the string
begins with 
.B 0u
), in hexadecimal (if it begins with 
.B 0x
or
.B 0X
), in octal (if it begins with 
.B 0o
or 
.B 0O
), or in binary
(if it begins with 
.B 0b
or 
.B 0B
)\&.
.sp
The 
.B 0u
prefix reads the input as an unsigned integer in the range
.B [0, 2*max_int+1]
\&.  If the input exceeds 
.B max_int
it is converted to the signed integer
.B min_int + input \- max_int \- 1
\&.
.sp
The 
.B _
(underscore) character can appear anywhere in the string
and is ignored\&.
.sp
Return 
.B None
if the given string is not a valid representation of an
integer, or if the integer represented exceeds the range of integers
representable in type 
.B int
\&.

.sp
.B "Since"
4.05

.sp

.I val int_of_string 
: 
.B string -> int
.sp
Same as 
.B int_of_string_opt
, but raise
.B Failure "int_of_string"
instead of returning 
.B None
\&.

.sp

.I val string_of_float 
: 
.B float -> string
.sp
Return the string representation of a floating\-point number\&.

.sp

.I val float_of_string_opt 
: 
.B string -> float option
.sp
Convert the given string to a float\&.  The string is read in decimal
(by default) or in hexadecimal (marked by 
.B 0x
or 
.B 0X
)\&.
.sp
The format of decimal floating\-point numbers is
.B  [\-] dd\&.ddd (e|E) [+|\-] dd 
, where 
.B d
stands for a decimal digit\&.
.sp
The format of hexadecimal floating\-point numbers is
.B  [\-] 0(x|X) hh\&.hhh (p|P) [+|\-] dd 
, where 
.B h
stands for an
hexadecimal digit and 
.B d
for a decimal digit\&.
.sp
In both cases, at least one of the integer and fractional parts must be
given; the exponent part is optional\&.
.sp
The 
.B _
(underscore) character can appear anywhere in the string
and is ignored\&.
.sp
Depending on the execution platforms, other representations of
floating\-point numbers can be accepted, but should not be relied upon\&.
.sp
Return 
.B None
if the given string is not a valid representation of a float\&.

.sp
.B "Since"
4.05

.sp

.I val float_of_string 
: 
.B string -> float
.sp
Same as 
.B float_of_string_opt
, but raise
.B Failure "float_of_string"
instead of returning 
.B None
\&.

.sp

.PP
.SS Pair operations

.PP

.I val fst 
: 
.B 'a * 'b -> 'a
.sp
Return the first component of a pair\&.

.sp

.I val snd 
: 
.B 'a * 'b -> 'b
.sp
Return the second component of a pair\&.

.sp

.PP
.SS List operations
.sp
More list operations are provided in module 
.B List
\&.
.PP

.I val (@) 
: 
.B 'a list -> 'a list -> 'a list
.sp
List concatenation\&.  Not tail\-recursive (length of the first argument)\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Input/output
Note: all input/output functions can raise 
.B Sys_error
when the system
calls they invoke fail\&.
.PP
.I type in_channel 

.sp
The type of input channel\&.

.sp
.I type out_channel 

.sp
The type of output channel\&.

.sp

.I val stdin 
: 
.B in_channel
.sp
The standard input for the process\&.

.sp

.I val stdout 
: 
.B out_channel
.sp
The standard output for the process\&.

.sp

.I val stderr 
: 
.B out_channel
.sp
The standard error output for the process\&.

.sp

.PP
.SS Output functions on standard output

.PP

.I val print_char 
: 
.B char -> unit
.sp
Print a character on standard output\&.

.sp

.I val print_string 
: 
.B string -> unit
.sp
Print a string on standard output\&.

.sp

.I val print_bytes 
: 
.B bytes -> unit
.sp
Print a byte sequence on standard output\&.

.sp
.B "Since"
4.02.0

.sp

.I val print_int 
: 
.B int -> unit
.sp
Print an integer, in decimal, on standard output\&.

.sp

.I val print_float 
: 
.B float -> unit
.sp
Print a floating\-point number, in decimal, on standard output\&.

.sp

.I val print_endline 
: 
.B string -> unit
.sp
Print a string, followed by a newline character, on
standard output and flush standard output\&.

.sp

.I val print_newline 
: 
.B unit -> unit
.sp
Print a newline character on standard output, and flush
standard output\&. This can be used to simulate line
buffering of standard output\&.

.sp

.PP
.SS Output functions on standard error

.PP

.I val prerr_char 
: 
.B char -> unit
.sp
Print a character on standard error\&.

.sp

.I val prerr_string 
: 
.B string -> unit
.sp
Print a string on standard error\&.

.sp

.I val prerr_bytes 
: 
.B bytes -> unit
.sp
Print a byte sequence on standard error\&.

.sp
.B "Since"
4.02.0

.sp

.I val prerr_int 
: 
.B int -> unit
.sp
Print an integer, in decimal, on standard error\&.

.sp

.I val prerr_float 
: 
.B float -> unit
.sp
Print a floating\-point number, in decimal, on standard error\&.

.sp

.I val prerr_endline 
: 
.B string -> unit
.sp
Print a string, followed by a newline character on standard
error and flush standard error\&.

.sp

.I val prerr_newline 
: 
.B unit -> unit
.sp
Print a newline character on standard error, and flush
standard error\&.

.sp

.PP
.SS Input functions on standard input

.PP

.I val read_line 
: 
.B unit -> string
.sp
Flush standard output, then read characters from standard input
until a newline character is encountered\&. Return the string of
all characters read, without the newline character at the end\&.

.sp

.I val read_int_opt 
: 
.B unit -> int option
.sp
Flush standard output, then read one line from standard input
and convert it to an integer\&.
.sp
Return 
.B None
if the line read is not a valid representation of an integer\&.

.sp
.B "Since"
4.05

.sp

.I val read_int 
: 
.B unit -> int
.sp
Same as 
.B read_int_opt
, but raise 
.B Failure "int_of_string"
instead of returning 
.B None
\&.

.sp

.I val read_float_opt 
: 
.B unit -> float option
.sp
Flush standard output, then read one line from standard input
and convert it to a floating\-point number\&.
.sp
Return 
.B None
if the line read is not a valid representation of a
floating\-point number\&.

.sp
.B "Since"
4.05.0

.sp

.I val read_float 
: 
.B unit -> float
.sp
Same as 
.B read_float_opt
, but raise 
.B Failure "float_of_string"
instead of returning 
.B None
\&.

.sp

.PP
.SS General output functions

.PP
.I type open_flag 
=
 | Open_rdonly  (* open for reading\&.
 *)
 | Open_wronly  (* open for writing\&.
 *)
 | Open_append  (* open for appending: always write at end of file\&.
 *)
 | Open_creat  (* create the file if it does not exist\&.
 *)
 | Open_trunc  (* empty the file if it already exists\&.
 *)
 | Open_excl  (* fail if Open_creat and the file already exists\&.
 *)
 | Open_binary  (* open in binary mode (no conversion)\&.
 *)
 | Open_text  (* open in text mode (may perform conversions)\&.
 *)
 | Open_nonblock  (* open in non\-blocking mode\&.
 *)
 
.sp
Opening modes for 
.B open_out_gen
and
.B open_in_gen
\&.

.sp

.I val open_out 
: 
.B string -> out_channel
.sp
Open the named file for writing, and return a new output channel
on that file, positioned at the beginning of the file\&. The
file is truncated to zero length if it already exists\&. It
is created if it does not already exists\&.

.sp

.I val open_out_bin 
: 
.B string -> out_channel
.sp
Same as 
.B open_out
, but the file is opened in binary mode,
so that no translation takes place during writes\&. On operating
systems that do not distinguish between text mode and binary
mode, this function behaves like 
.B open_out
\&.

.sp

.I val open_out_gen 
: 
.B open_flag list -> int -> string -> out_channel
.sp

.B open_out_gen mode perm filename
opens the named file for writing,
as described above\&. The extra argument 
.B mode
specifies the opening mode\&. The extra argument 
.B perm
specifies
the file permissions, in case the file must be created\&.
.B open_out
and 
.B open_out_bin
are special
cases of this function\&.

.sp

.I val flush 
: 
.B out_channel -> unit
.sp
Flush the buffer associated with the given output channel,
performing all pending writes on that channel\&.
Interactive programs must be careful about flushing standard
output and standard error at the right time\&.

.sp

.I val flush_all 
: 
.B unit -> unit
.sp
Flush all open output channels; ignore errors\&.

.sp

.I val output_char 
: 
.B out_channel -> char -> unit
.sp
Write the character on the given output channel\&.

.sp

.I val output_string 
: 
.B out_channel -> string -> unit
.sp
Write the string on the given output channel\&.

.sp

.I val output_bytes 
: 
.B out_channel -> bytes -> unit
.sp
Write the byte sequence on the given output channel\&.

.sp
.B "Since"
4.02.0

.sp

.I val output 
: 
.B out_channel -> bytes -> int -> int -> unit
.sp

.B output oc buf pos len
writes 
.B len
characters from byte sequence 
.B buf
,
starting at offset 
.B pos
, to the given output channel 
.B oc
\&.
Raise 
.B Invalid_argument "output"
if 
.B pos
and 
.B len
do not
designate a valid range of 
.B buf
\&.

.sp

.I val output_substring 
: 
.B out_channel -> string -> int -> int -> unit
.sp
Same as 
.B output
but take a string as argument instead of
a byte sequence\&.

.sp
.B "Since"
4.02.0

.sp

.I val output_byte 
: 
.B out_channel -> int -> unit
.sp
Write one 8\-bit integer (as the single character with that code)
on the given output channel\&. The given integer is taken modulo
256\&.

.sp

.I val output_binary_int 
: 
.B out_channel -> int -> unit
.sp
Write one integer in binary format (4 bytes, big\-endian)
on the given output channel\&.
The given integer is taken modulo 2^32\&.
The only reliable way to read it back is through the
.B input_binary_int
function\&. The format is compatible across
all machines for a given version of OCaml\&.

.sp

.I val output_value 
: 
.B out_channel -> 'a -> unit
.sp
Write the representation of a structured value of any type
to a channel\&. Circularities and sharing inside the value
are detected and preserved\&. The object can be read back,
by the function 
.B input_value
\&. See the description of module
.B Marshal
for more information\&. 
.B output_value
is equivalent
to 
.B Marshal\&.to_channel
with an empty list of flags\&.

.sp

.I val seek_out 
: 
.B out_channel -> int -> unit
.sp

.B seek_out chan pos
sets the current writing position to 
.B pos
for channel 
.B chan
\&. This works only for regular files\&. On
files of other kinds (such as terminals, pipes and sockets),
the behavior is unspecified\&.

.sp

.I val pos_out 
: 
.B out_channel -> int
.sp
Return the current writing position for the given channel\&.  Does
not work on channels opened with the 
.B Open_append
flag (returns
unspecified results)\&.

.sp

.I val out_channel_length 
: 
.B out_channel -> int
.sp
Return the size (number of characters) of the regular file
on which the given channel is opened\&.  If the channel is opened
on a file that is not a regular file, the result is meaningless\&.

.sp

.I val close_out 
: 
.B out_channel -> unit
.sp
Close the given channel, flushing all buffered write operations\&.
Output functions raise a 
.B Sys_error
exception when they are
applied to a closed output channel, except 
.B close_out
and 
.B flush
,
which do nothing when applied to an already closed channel\&.
Note that 
.B close_out
may raise 
.B Sys_error
if the operating
system signals an error when flushing or closing\&.

.sp

.I val close_out_noerr 
: 
.B out_channel -> unit
.sp
Same as 
.B close_out
, but ignore all errors\&.

.sp

.I val set_binary_mode_out 
: 
.B out_channel -> bool -> unit
.sp

.B set_binary_mode_out oc true
sets the channel 
.B oc
to binary
mode: no translations take place during output\&.
.B set_binary_mode_out oc false
sets the channel 
.B oc
to text
mode: depending on the operating system, some translations
may take place during output\&.  For instance, under Windows,
end\-of\-lines will be translated from 
.B \(rsn
to 
.B \(rsr\(rsn
\&.
This function has no effect under operating systems that
do not distinguish between text mode and binary mode\&.

.sp

.PP
.SS General input functions

.PP

.I val open_in 
: 
.B string -> in_channel
.sp
Open the named file for reading, and return a new input channel
on that file, positioned at the beginning of the file\&.

.sp

.I val open_in_bin 
: 
.B string -> in_channel
.sp
Same as 
.B open_in
, but the file is opened in binary mode,
so that no translation takes place during reads\&. On operating
systems that do not distinguish between text mode and binary
mode, this function behaves like 
.B open_in
\&.

.sp

.I val open_in_gen 
: 
.B open_flag list -> int -> string -> in_channel
.sp

.B open_in_gen mode perm filename
opens the named file for reading,
as described above\&. The extra arguments
.B mode
and 
.B perm
specify the opening mode and file permissions\&.
.B open_in
and 
.B open_in_bin
are special
cases of this function\&.

.sp

.I val input_char 
: 
.B in_channel -> char
.sp
Read one character from the given input channel\&.
Raise 
.B End_of_file
if there are no more characters to read\&.

.sp

.I val input_line 
: 
.B in_channel -> string
.sp
Read characters from the given input channel, until a
newline character is encountered\&. Return the string of
all characters read, without the newline character at the end\&.
Raise 
.B End_of_file
if the end of the file is reached
at the beginning of line\&.

.sp

.I val input 
: 
.B in_channel -> bytes -> int -> int -> int
.sp

.B input ic buf pos len
reads up to 
.B len
characters from
the given channel 
.B ic
, storing them in byte sequence 
.B buf
, starting at
character number 
.B pos
\&.
It returns the actual number of characters read, between 0 and
.B len
(inclusive)\&.
A return value of 0 means that the end of file was reached\&.
A return value between 0 and 
.B len
exclusive means that
not all requested 
.B len
characters were read, either because
no more characters were available at that time, or because
the implementation found it convenient to do a partial read;
.B input
must be called again to read the remaining characters,
if desired\&.  (See also 
.B really_input
for reading
exactly 
.B len
characters\&.)
Exception 
.B Invalid_argument "input"
is raised if 
.B pos
and 
.B len
do not designate a valid range of 
.B buf
\&.

.sp

.I val really_input 
: 
.B in_channel -> bytes -> int -> int -> unit
.sp

.B really_input ic buf pos len
reads 
.B len
characters from channel 
.B ic
,
storing them in byte sequence 
.B buf
, starting at character number 
.B pos
\&.
Raise 
.B End_of_file
if the end of file is reached before 
.B len
characters have been read\&.
Raise 
.B Invalid_argument "really_input"
if
.B pos
and 
.B len
do not designate a valid range of 
.B buf
\&.

.sp

.I val really_input_string 
: 
.B in_channel -> int -> string
.sp

.B really_input_string ic len
reads 
.B len
characters from channel 
.B ic
and returns them in a new string\&.
Raise 
.B End_of_file
if the end of file is reached before 
.B len
characters have been read\&.

.sp
.B "Since"
4.02.0

.sp

.I val input_byte 
: 
.B in_channel -> int
.sp
Same as 
.B input_char
, but return the 8\-bit integer representing
the character\&.
Raise 
.B End_of_file
if an end of file was reached\&.

.sp

.I val input_binary_int 
: 
.B in_channel -> int
.sp
Read an integer encoded in binary format (4 bytes, big\-endian)
from the given input channel\&. See 
.B output_binary_int
\&.
Raise 
.B End_of_file
if an end of file was reached while reading the
integer\&.

.sp

.I val input_value 
: 
.B in_channel -> 'a
.sp
Read the representation of a structured value, as produced
by 
.B output_value
, and return the corresponding value\&.
This function is identical to 
.B Marshal\&.from_channel
;
see the description of module 
.B Marshal
for more information,
in particular concerning the lack of type safety\&.

.sp

.I val seek_in 
: 
.B in_channel -> int -> unit
.sp

.B seek_in chan pos
sets the current reading position to 
.B pos
for channel 
.B chan
\&. This works only for regular files\&. On
files of other kinds, the behavior is unspecified\&.

.sp

.I val pos_in 
: 
.B in_channel -> int
.sp
Return the current reading position for the given channel\&.

.sp

.I val in_channel_length 
: 
.B in_channel -> int
.sp
Return the size (number of characters) of the regular file
on which the given channel is opened\&.  If the channel is opened
on a file that is not a regular file, the result is meaningless\&.
The returned size does not take into account the end\-of\-line
translations that can be performed when reading from a channel
opened in text mode\&.

.sp

.I val close_in 
: 
.B in_channel -> unit
.sp
Close the given channel\&.  Input functions raise a 
.B Sys_error
exception when they are applied to a closed input channel,
except 
.B close_in
, which does nothing when applied to an already
closed channel\&.

.sp

.I val close_in_noerr 
: 
.B in_channel -> unit
.sp
Same as 
.B close_in
, but ignore all errors\&.

.sp

.I val set_binary_mode_in 
: 
.B in_channel -> bool -> unit
.sp

.B set_binary_mode_in ic true
sets the channel 
.B ic
to binary
mode: no translations take place during input\&.
.B set_binary_mode_out ic false
sets the channel 
.B ic
to text
mode: depending on the operating system, some translations
may take place during input\&.  For instance, under Windows,
end\-of\-lines will be translated from 
.B \(rsr\(rsn
to 
.B \(rsn
\&.
This function has no effect under operating systems that
do not distinguish between text mode and binary mode\&.

.sp

.PP
.SS Operations on large files

.PP
.I module LargeFile : 
.B sig  end

.sp
Operations on large files\&.
This sub\-module provides 64\-bit variants of the channel functions
that manipulate file positions and file sizes\&.  By representing
positions and sizes by 64\-bit integers (type 
.B int64
) instead of
regular integers (type 
.B int
), these alternate functions allow
operating on files whose sizes are greater than 
.B max_int
\&.

.sp

.PP
.SS References

.PP
.I type 
.B 'a
.I ref 
= {

.B mutable 
contents : 
.B 'a
;
 }

.sp
The type of references (mutable indirection cells) containing
a value of type 
.B \&'a
\&.

.sp

.I val ref 
: 
.B 'a -> 'a ref
.sp
Return a fresh reference containing the given value\&.

.sp

.I val (!) 
: 
.B 'a ref -> 'a
.sp

.B !r
returns the current contents of reference 
.B r
\&.
Equivalent to 
.B fun r \-> r\&.contents
\&.
Unary operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val (:=) 
: 
.B 'a ref -> 'a -> unit
.sp

.B r := a
stores the value of 
.B a
in reference 
.B r
\&.
Equivalent to 
.B fun r v \-> r\&.contents <\- v
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.I val incr 
: 
.B int ref -> unit
.sp
Increment the integer contained in the given reference\&.
Equivalent to 
.B fun r \-> r := succ !r
\&.

.sp

.I val decr 
: 
.B int ref -> unit
.sp
Decrement the integer contained in the given reference\&.
Equivalent to 
.B fun r \-> r := pred !r
\&.

.sp

.PP
.SS Result type

.PP
.I type 
.B ('a, 'b)
.I result 
=
 | Ok
.B of 
.B 'a
 | Error
.B of 
.B 'b
 
.sp
.B "Since"
4.03.0

.sp

.PP
.SS Operations on format strings

.PP

.PP
Format strings are character strings with special lexical conventions
that defines the functionality of formatted input/output functions\&. Format
strings are used to read data with formatted input functions from module
.B Scanf
and to print data with formatted output functions from modules
.B Printf
and 
.B Format
\&.
.sp
Format strings are made of three kinds of entities:
.sp
\-conversions specifications, introduced by the special character 
.B \&'%\&'
followed by one or more characters specifying what kind of argument to
read or print,
.sp
\-formatting indications, introduced by the special character 
.B \&'@\&'
followed by one or more characters specifying how to read or print the
argument,
.sp
\-plain characters that are regular characters with usual lexical
conventions\&. Plain characters specify string literals to be read in the
input or printed in the output\&.

There is an additional lexical rule to escape the special characters 
.B \&'%\&'
and 
.B \&'@\&'
in format strings: if a special character follows a 
.B \&'%\&'
character, it is treated as a plain character\&. In other words, 
.B "%%"
is
considered as a plain 
.B \&'%\&'
and 
.B "%@"
as a plain 
.B \&'@\&'
\&.
.sp
For more information about conversion specifications and formatting
indications available, read the documentation of modules 
.B Scanf
,
.B Printf
and 
.B Format
\&.
.PP

.PP
Format strings have a general and highly polymorphic type
.B (\&'a, \&'b, \&'c, \&'d, \&'e, \&'f) format6
\&.
The two simplified types, 
.B format
and 
.B format4
below are
included for backward compatibility with earlier releases of
OCaml\&.
.sp
The meaning of format string type parameters is as follows:
.sp
.sp
\-
.B \&'a
is the type of the parameters of the format for formatted output
functions (
.B printf
\-style functions);
.B \&'a
is the type of the values read by the format for formatted input
functions (
.B scanf
\-style functions)\&.

.sp
\-
.B \&'b
is the type of input source for formatted input functions and the
type of output target for formatted output functions\&.
For 
.B printf
\-style functions from module 
.B Printf
, 
.B \&'b
is typically
.B out_channel
;
for 
.B printf
\-style functions from module 
.B Format
, 
.B \&'b
is typically
.B Format\&.formatter
;
for 
.B scanf
\-style functions from module 
.B Scanf
, 
.B \&'b
is typically
.B Scanf\&.Scanning\&.in_channel
\&.

Type argument 
.B \&'b
is also the type of the first argument given to
user\&'s defined printing functions for 
.B %a
and 
.B %t
conversions,
and user\&'s defined reading functions for 
.B %r
conversion\&.
.sp
.sp
\-
.B \&'c
is the type of the result of the 
.B %a
and 
.B %t
printing
functions, and also the type of the argument transmitted to the
first argument of 
.B kprintf
\-style functions or to the
.B kscanf
\-style functions\&.

.sp
\-
.B \&'d
is the type of parameters for the 
.B scanf
\-style functions\&.

.sp
\-
.B \&'e
is the type of the receiver function for the 
.B scanf
\-style functions\&.

.sp
\-
.B \&'f
is the final result type of a formatted input/output function
invocation: for the 
.B printf
\-style functions, it is typically 
.B unit
;
for the 
.B scanf
\-style functions, it is typically the result type of the
receiver function\&.

.PP
.I type 
.B ('a, 'b, 'c, 'd, 'e, 'f)
.I format6 
= 
.B ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6

.sp

.sp
.I type 
.B ('a, 'b, 'c, 'd)
.I format4 
= 
.B ('a, 'b, 'c, 'c, 'c, 'd) format6

.sp

.sp
.I type 
.B ('a, 'b, 'c)
.I format 
= 
.B ('a, 'b, 'c, 'c) format4

.sp

.sp

.I val string_of_format 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 -> string
.sp
Converts a format string into a string\&.

.sp

.I val format_of_string 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6
.sp

.B format_of_string s
returns a format string read from the string
literal 
.B s
\&.
Note: 
.B format_of_string
can not convert a string argument that is not a
literal\&. If you need this functionality, use the more general
.B Scanf\&.format_from_string
function\&.

.sp

.I val (^^) 
: 
.B ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   ('f, 'b, 'c, 'e, 'g, 'h) format6 ->
.B   ('a, 'b, 'c, 'd, 'g, 'h) format6
.sp

.B f1 ^^ f2
catenates format strings 
.B f1
and 
.B f2
\&. The result is a
format string that behaves as the concatenation of format strings 
.B f1
and
.B f2
: in case of formatted output, it accepts arguments from 
.B f1
, then
arguments from 
.B f2
; in case of formatted input, it returns results from
.B f1
, then results from 
.B f2
\&.
Right\-associative operator, see 
.B Ocaml_operators
for more information\&.

.sp

.PP
.SS Program termination

.PP

.I val exit 
: 
.B int -> 'a
.sp
Terminate the process, returning the given status code
to the operating system: usually 0 to indicate no errors,
and a small positive integer to indicate failure\&.
All open output channels are flushed with 
.B flush_all
\&.
An implicit 
.B exit 0
is performed each time a program
terminates normally\&.  An implicit 
.B exit 2
is performed if the program
terminates early because of an uncaught exception\&.

.sp

.I val at_exit 
: 
.B (unit -> unit) -> unit
.sp
Register the given function to be called at program termination
time\&. The functions registered with 
.B at_exit
will be called when
the program does any of the following:
.sp
\-executes 
.B exit

.sp
\-terminates, either normally or because of an uncaught
exception
.sp
\-executes the C function 
.B caml_shutdown
\&.
The functions are called in \&'last in, first out\&' order: the
function most recently added with 
.B at_exit
is called first\&.


.sp

.PP
.SS Standard library modules 

.PP
.I module Arg : 
.B (module Stdlib__arg)

.sp

.sp
.I module Array : 
.B (module Stdlib__array)

.sp

.sp
.I module ArrayLabels : 
.B (module Stdlib__arrayLabels)

.sp

.sp
.I module Bigarray : 
.B (module Stdlib__bigarray)

.sp

.sp
.I module Bool : 
.B (module Stdlib__bool)

.sp

.sp
.I module Buffer : 
.B (module Stdlib__buffer)

.sp

.sp
.I module Bytes : 
.B (module Stdlib__bytes)

.sp

.sp
.I module BytesLabels : 
.B (module Stdlib__bytesLabels)

.sp

.sp
.I module Callback : 
.B (module Stdlib__callback)

.sp

.sp
.I module Char : 
.B (module Stdlib__char)

.sp

.sp
.I module Complex : 
.B (module Stdlib__complex)

.sp

.sp
.I module Digest : 
.B (module Stdlib__digest)

.sp

.sp
.I module Ephemeron : 
.B (module Stdlib__ephemeron)

.sp

.sp
.I module Filename : 
.B (module Stdlib__filename)

.sp

.sp
.I module Float : 
.B (module Stdlib__float)

.sp

.sp
.I module Format : 
.B (module Stdlib__format)

.sp

.sp
.I module Fun : 
.B (module Stdlib__fun)

.sp

.sp
.I module Gc : 
.B (module Stdlib__gc)

.sp

.sp
.I module Genlex : 
.B (module Stdlib__genlex)

.sp

.sp
.I module Hashtbl : 
.B (module Stdlib__hashtbl)

.sp

.sp
.I module Int : 
.B (module Stdlib__int)

.sp

.sp
.I module Int32 : 
.B (module Stdlib__int32)

.sp

.sp
.I module Int64 : 
.B (module Stdlib__int64)

.sp

.sp
.I module Lazy : 
.B (module Stdlib__lazy)

.sp

.sp
.I module Lexing : 
.B (module Stdlib__lexing)

.sp

.sp
.I module List : 
.B (module Stdlib__list)

.sp

.sp
.I module ListLabels : 
.B (module Stdlib__listLabels)

.sp

.sp
.I module Map : 
.B (module Stdlib__map)

.sp

.sp
.I module Marshal : 
.B (module Stdlib__marshal)

.sp

.sp
.I module MoreLabels : 
.B (module Stdlib__moreLabels)

.sp

.sp
.I module Nativeint : 
.B (module Stdlib__nativeint)

.sp

.sp
.I module Obj : 
.B (module Stdlib__obj)

.sp

.sp
.I module Oo : 
.B (module Stdlib__oo)

.sp

.sp
.I module Option : 
.B (module Stdlib__option)

.sp

.sp
.I module Parsing : 
.B (module Stdlib__parsing)

.sp

.sp
.I module Pervasives : 
.B (module Stdlib__pervasives)

.sp

.sp
.I module Printexc : 
.B (module Stdlib__printexc)

.sp

.sp
.I module Printf : 
.B (module Stdlib__printf)

.sp

.sp
.I module Queue : 
.B (module Stdlib__queue)

.sp

.sp
.I module Random : 
.B (module Stdlib__random)

.sp

.sp
.I module Result : 
.B (module Stdlib__result)

.sp

.sp
.I module Scanf : 
.B (module Stdlib__scanf)

.sp

.sp
.I module Seq : 
.B (module Stdlib__seq)

.sp

.sp
.I module Set : 
.B (module Stdlib__set)

.sp

.sp
.I module Spacetime : 
.B (module Stdlib__spacetime)

.sp

.sp
.I module Stack : 
.B (module Stdlib__stack)

.sp

.sp
.I module StdLabels : 
.B (module Stdlib__stdLabels)

.sp

.sp
.I module Stream : 
.B (module Stdlib__stream)

.sp

.sp
.I module String : 
.B (module Stdlib__string)

.sp

.sp
.I module StringLabels : 
.B (module Stdlib__stringLabels)

.sp

.sp
.I module Sys : 
.B (module Stdlib__sys)

.sp

.sp
.I module Uchar : 
.B (module Stdlib__uchar)

.sp

.sp
.I module Unit : 
.B (module Stdlib__unit)

.sp

.sp
.I module Weak : 
.B (module Stdlib__weak)

.sp

.sp
