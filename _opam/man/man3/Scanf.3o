.TH "Scanf" 3 2019-11-22 OCamldoc "OCaml library"
.SH NAME
Scanf \- Formatted input functions.
.SH Module
Module   Scanf
.SH Documentation
.sp
Module
.BI "Scanf"
 : 
.B sig  end

.sp
Formatted input functions\&.

.sp

.sp
.sp

.PP
.SS Introduction

.PP

.PP
.SS Functional input with format strings

.PP

.PP
The module 
.B Scanf
provides formatted input functions or scanners\&.
.sp
The formatted input functions can read from any kind of input, including
strings, files, or anything that can return characters\&. The more general
source of characters is named a formatted input channel (or     scanning buffer) and has type 
.B Scanf\&.Scanning\&.in_channel
\&. The more general
formatted input function reads from any scanning buffer and is named
.B bscanf
\&.
.sp
Generally speaking, the formatted input functions have 3 arguments:
.sp
\-the first argument is a source of characters for the input,
.sp
\-the second argument is a format string that specifies the values to
read,
.sp
\-the third argument is a receiver function that is applied to the
values read\&.

Hence, a typical call to the formatted input function 
.B Scanf\&.bscanf
is
.B bscanf ic fmt f
, where:
.sp
.sp
\-
.B ic
is a source of characters (typically a     formatted input channel with type 
.B Scanf\&.Scanning\&.in_channel
),

.sp
\-
.B fmt
is a format string (the same format strings as those used to print
material with module 
.B Printf
or 
.B Format
),

.sp
\-
.B f
is a function that has as many arguments as the number of values to
read in the input according to 
.B fmt
\&.

.PP

.PP
.SS A simple example

.PP

.PP
As suggested above, the expression 
.B bscanf ic "%d" f
reads a decimal
integer 
.B n
from the source of characters 
.B ic
and returns 
.B f n
\&.
.sp
For instance,
.sp
.sp
\-if we use 
.B stdin
as the source of characters (
.B Scanf\&.Scanning\&.stdin
is
the predefined formatted input channel that reads from standard input),

.sp
\-if we define the receiver 
.B f
as 
.B let f x = x + 1
,

then 
.B bscanf Scanning\&.stdin "%d" f
reads an integer 
.B n
from the
standard input and returns 
.B f n
(that is 
.B n + 1
)\&. Thus, if we
evaluate 
.B bscanf stdin "%d" f
, and then enter 
.B 41
at the
keyboard, the result we get is 
.B 42
\&.
.PP

.PP
.SS Formatted input as a functional feature

.PP

.PP
The OCaml scanning facility is reminiscent of the corresponding C feature\&.
However, it is also largely different, simpler, and yet more powerful:
the formatted input functions are higher\-order functionals and the
parameter passing mechanism is just the regular function application not
the variable assignment based mechanism which is typical for formatted
input in imperative languages; the OCaml format strings also feature
useful additions to easily define complex tokens; as expected within a
functional programming language, the formatted input functions also
support polymorphism, in particular arbitrary interaction with
polymorphic user\-defined scanners\&. Furthermore, the OCaml formatted input
facility is fully type\-checked at compile time\&.
.PP

.PP
.SS Formatted input channel

.PP
.I module Scanning : 
.B sig  end

.sp

.sp

.PP
.SS Type of formatted input functions

.PP
.I type 
.B ('a, 'b, 'c, 'd)
.I scanner 
= 
.B ('a, Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c

.sp
The type of formatted input scanners: 
.B (\&'a, \&'b, \&'c, \&'d) scanner
is the type of a formatted input function that reads from some
formatted input channel according to some format string; more
precisely, if 
.B scan
is some formatted input function, then 
.B scan
.B     ic fmt f
applies 
.B f
to all the arguments specified by format
string 
.B fmt
, when 
.B scan
has read those arguments from the
.B Scanf\&.Scanning\&.in_channel
formatted input channel 
.B ic
\&.
.sp
For instance, the 
.B Scanf\&.scanf
function below has type
.B (\&'a, \&'b, \&'c, \&'d) scanner
, since it is a formatted input function that
reads from 
.B Scanf\&.Scanning\&.stdin
: 
.B scanf fmt f
applies 
.B f
to the arguments
specified by 
.B fmt
, reading those arguments from 
.B stdin
as
expected\&.
.sp
If the format 
.B fmt
has some 
.B %r
indications, the corresponding
formatted input functions must be provided before receiver function
.B f
\&. For instance, if 
.B read_elem
is an input function for values of type
.B t
, then 
.B bscanf ic "%r;" read_elem f
reads a value 
.B v
of type 
.B t
followed by a 
.B \&';\&'
character, and returns 
.B f v
\&.

.sp
.B "Since"
3.10.0

.sp

.I exception Scan_failure 
.B of 
.B string

.sp
When the input can not be read according to the format string
specification, formatted input functions typically raise exception
.B Scan_failure
\&.

.sp

.PP
.SS The general formatted input function

.PP

.I val bscanf 
: 
.B Scanning.in_channel -> ('a, 'b, 'c, 'd) scanner
.sp

.sp

.PP

.B bscanf ic fmt r1 \&.\&.\&. rN f
reads characters from the
.B Scanf\&.Scanning\&.in_channel
formatted input channel 
.B ic
and converts them to
values according to format string 
.B fmt
\&.
As a final step, receiver function 
.B f
is applied to the values read and
gives the result of the 
.B bscanf
call\&.
.sp
For instance, if 
.B f
is the function 
.B fun s i \-> i + 1
, then
.B Scanf\&.sscanf "x= 1" "%s = %i" f
returns 
.B 2
\&.
.sp
Arguments 
.B r1
to 
.B rN
are user\-defined input functions that read the
argument corresponding to the 
.B %r
conversions specified in the format
string\&.
.PP

.PP
.SS Format string description

.PP

.PP
The format string is a character string which contains three types of
objects:
.sp
\-plain characters, which are simply matched with the characters of the
input (with a special case for space and line feed, see 
.B Scanf\&.space
),
.sp
\-conversion specifications, each of which causes reading and conversion of
one argument for the function 
.B f
(see 
.B Scanf\&.conversion
),
.sp
\-scanning indications to specify boundaries of tokens
(see scanning 
.B Scanf\&.indication
)\&.

.PP

.PP
.SS The space character in format strings

.PP

.PP
As mentioned above, a plain character in the format string is just
matched with the next character of the input; however, two characters are
special exceptions to this rule: the space character (
.B \&' \&'
or ASCII code
32) and the line feed character (
.B \&'\(rsn\&'
or ASCII code 10)\&.
A space does not match a single space character, but any amount of
\&'whitespace\&' in the input\&. More precisely, a space inside the format
string matches any number of tab, space, line feed and carriage
return characters\&. Similarly, a line feed character in the format string
matches either a single line feed or a carriage return followed by a line
feed\&.
.sp
Matching any amount of whitespace, a space in the format string
also matches no amount of whitespace at all; hence, the call 
.B bscanf ib
.B     "Price = %d $" (fun p \-> p)
succeeds and returns 
.B 1
when reading an
input with various whitespace in it, such as 
.B Price = 1 $
,
.B Price  =  1    $
, or even 
.B Price=1$
\&.
.PP

.PP
.SS Conversion specifications in format strings

.PP

.PP
Conversion specifications consist in the 
.B %
character, followed by
an optional flag, an optional field width, and followed by one or
two conversion characters\&.
.sp
The conversion characters and their meanings are:
.sp
.sp
\-
.B d
: reads an optionally signed decimal integer (
.B 0\-9
+)\&.
.sp
\-
.B i
: reads an optionally signed integer
(usual input conventions for decimal (
.B 0\-9
+), hexadecimal
(
.B 0x[0\-9a\-f]+
and 
.B 0X[0\-9A\-F]+
), octal (
.B 0o[0\-7]+
), and binary
(
.B 0b[0\-1]+
) notations are understood)\&.
.sp
\-
.B u
: reads an unsigned decimal integer\&.
.sp
\-
.B x
or 
.B X
: reads an unsigned hexadecimal integer (
.B [0\-9a\-fA\-F]+
)\&.
.sp
\-
.B o
: reads an unsigned octal integer (
.B [0\-7]+
)\&.
.sp
\-
.B s
: reads a string argument that spreads as much as possible, until the
following bounding condition holds: 
.sp
\-a whitespace has been found (see 
.B Scanf\&.space
),
.sp
\-a scanning indication (see scanning 
.B Scanf\&.indication
) has been
encountered,
.sp
\-the end\-of\-input has been reached\&.

Hence, this conversion always succeeds: it returns an empty
string if the bounding condition holds when the scan begins\&.
.sp
\-
.B S
: reads a delimited string argument (delimiters and special
escaped characters follow the lexical conventions of OCaml)\&.
.sp
\-
.B c
: reads a single character\&. To test the current input character
without reading it, specify a null field width, i\&.e\&. use
specification 
.B %0c
\&. Raise 
.B Invalid_argument
, if the field width
specification is greater than 1\&.
.sp
\-
.B C
: reads a single delimited character (delimiters and special
escaped characters follow the lexical conventions of OCaml)\&.
.sp
\-
.B f
, 
.B e
, 
.B E
, 
.B g
, 
.B G
: reads an optionally signed
floating\-point number in decimal notation, in the style 
.B dddd\&.ddd
.B       e/E+\-dd
\&.
.sp
\-
.B h
, 
.B H
: reads an optionally signed floating\-point number
in hexadecimal notation\&.
.sp
\-
.B F
: reads a floating point number according to the lexical
conventions of OCaml (hence the decimal point is mandatory if the
exponent part is not mentioned)\&.
.sp
\-
.B B
: reads a boolean argument (
.B true
or 
.B false
)\&.
.sp
\-
.B b
: reads a boolean argument (for backward compatibility; do not use
in new programs)\&.
.sp
\-
.B ld
, 
.B li
, 
.B lu
, 
.B lx
, 
.B lX
, 
.B lo
: reads an 
.B int32
argument to
the format specified by the second letter for regular integers\&.
.sp
\-
.B nd
, 
.B ni
, 
.B nu
, 
.B nx
, 
.B nX
, 
.B no
: reads a 
.B nativeint
argument to
the format specified by the second letter for regular integers\&.
.sp
\-
.B Ld
, 
.B Li
, 
.B Lu
, 
.B Lx
, 
.B LX
, 
.B Lo
: reads an 
.B int64
argument to
the format specified by the second letter for regular integers\&.
.sp
\-
.B [ range ]
: reads characters that matches one of the characters
mentioned in the range of characters 
.B range
(or not mentioned in
it, if the range starts with 
.B ^
)\&. Reads a 
.B string
that can be
empty, if the next input character does not match the range\&. The set of
characters from 
.B c1
to 
.B c2
(inclusively) is denoted by 
.B c1\-c2
\&.
Hence, 
.B %[0\-9]
returns a string representing a decimal number
or an empty string if no decimal digit is found; similarly,
.B %[0\-9a\-f]
returns a string of hexadecimal digits\&.
If a closing bracket appears in a range, it must occur as the
first character of the range (or just after the 
.B ^
in case of
range negation); hence 
.B []]
matches a 
.B ]
character and
.B [^]]
matches any character that is not 
.B ]
\&.
Use 
.B %%
and 
.B %@
to include a 
.B %
or a 
.B @
in a range\&.
.sp
\-
.B r
: user\-defined reader\&. Takes the next 
.B ri
formatted input
function and applies it to the scanning buffer 
.B ib
to read the
next argument\&. The input function 
.B ri
must therefore have type
.B Scanning\&.in_channel \-> \&'a
and the argument read has type 
.B \&'a
\&.
.sp
\-
.B { fmt %}
: reads a format string argument\&. The format string
read must have the same type as the format string specification
.B fmt
\&. For instance, 
.B "%{ %i %}"
reads any format string that
can read a value of type 
.B int
; hence, if 
.B s
is the string
.B "fmt:\(rs"number is %u\(rs""
, then 
.B Scanf\&.sscanf s "fmt: %{%i%}"
succeeds and returns the format string 
.B "number is %u"
\&.
.sp
\-
.B ( fmt %)
: scanning sub\-format substitution\&.
Reads a format string 
.B rf
in the input, then goes on scanning with
.B rf
instead of scanning with 
.B fmt
\&.
The format string 
.B rf
must have the same type as the format string
specification 
.B fmt
that it replaces\&.
For instance, 
.B "%( %i %)"
reads any format string that can read a value
of type 
.B int
\&.
The conversion returns the format string read 
.B rf
, and then a value
read using 
.B rf
\&.
Hence, if 
.B s
is the string 
.B "\(rs"%4d\(rs"1234\&.00"
, then
.B Scanf\&.sscanf s "%(%i%)" (fun fmt i \-> fmt, i)
evaluates to
.B ("%4d", 1234)
\&.
This behaviour is not mere format substitution, since the conversion
returns the format string read as additional argument\&. If you need
pure format substitution, use special flag 
.B _
to discard the
extraneous argument: conversion 
.B %_( fmt %)
reads a format string
.B rf
and then behaves the same as format string 
.B rf
\&.  Hence, if 
.B s
is
the string 
.B "\(rs"%4d\(rs"1234\&.00"
, then 
.B Scanf\&.sscanf s "%_(%i%)"
is
simply equivalent to 
.B Scanf\&.sscanf "1234\&.00" "%4d"
\&.
.sp
\-
.B l
: returns the number of lines read so far\&.
.sp
\-
.B n
: returns the number of characters read so far\&.
.sp
\-
.B N
or 
.B L
: returns the number of tokens read so far\&.
.sp
\-
.B !
: matches the end of input condition\&.
.sp
\-
.B %
: matches one 
.B %
character in the input\&.
.sp
\-
.B @
: matches one 
.B @
character in the input\&.
.sp
\-
.B ,
: does nothing\&.

Following the 
.B %
character that introduces a conversion, there may be
the special flag 
.B _
: the conversion that follows occurs as usual,
but the resulting value is discarded\&.
For instance, if 
.B f
is the function 
.B fun i \-> i + 1
, and 
.B s
is the
string 
.B "x = 1"
, then 
.B Scanf\&.sscanf s "%_s = %i" f
returns 
.B 2
\&.
.sp
The field width is composed of an optional integer literal
indicating the maximal width of the token to read\&.
For instance, 
.B %6d
reads an integer, having at most 6 decimal digits;
.B %4f
reads a float with at most 4 characters; and 
.B %8[\(rs000\-\(rs255]
returns the next 8 characters (or all the characters still available,
if fewer than 8 characters are available in the input)\&.
.sp
Notes:
.sp
.sp
\-as mentioned above, a 
.B %s
conversion always succeeds, even if there is
nothing to read in the input: in this case, it simply returns 
.B ""
\&.

.sp
\-in addition to the relevant digits, 
.B \&'_\&'
characters may appear
inside numbers (this is reminiscent to the usual OCaml lexical
conventions)\&. If stricter scanning is desired, use the range
conversion facility instead of the number conversions\&.

.sp
\-the 
.B scanf
facility is not intended for heavy duty lexical
analysis and parsing\&. If it appears not expressive enough for your
needs, several alternative exists: regular expressions (module
.B Str
), stream parsers, 
.B ocamllex
\-generated lexers,
.B ocamlyacc
\-generated parsers\&.

.PP

.PP
.SS Scanning indications in format strings

.PP

.PP
Scanning indications appear just after the string conversions 
.B %s
and 
.B %[ range ]
to delimit the end of the token\&. A scanning
indication is introduced by a 
.B @
character, followed by some
plain character 
.B c
\&. It means that the string token should end
just before the next matching 
.B c
(which is skipped)\&. If no 
.B c
character is encountered, the string token spreads as much as
possible\&. For instance, 
.B "%s@\(rst"
reads a string up to the next
tab character or to the end of input\&. If a 
.B @
character appears
anywhere else in the format string, it is treated as a plain character\&.
.sp
Note:
.sp
.sp
\-As usual in format strings, 
.B %
and 
.B @
characters must be escaped
using 
.B %%
and 
.B %@
; this rule still holds within range specifications
and scanning indications\&.
For instance, format 
.B "%s@%%"
reads a string up to the next 
.B %
character, and format 
.B "%s@%@"
reads a string up to the next 
.B @
\&.
.sp
\-The scanning indications introduce slight differences in the syntax of
.B Scanf
format strings, compared to those used for the 
.B Printf
module\&. However, the scanning indications are similar to those used in
the 
.B Format
module; hence, when producing formatted text to be scanned
by 
.B Scanf\&.bscanf
, it is wise to use printing functions from the
.B Format
module (or, if you need to use functions from 
.B Printf
, banish
or carefully double check the format strings that contain 
.B \&'@\&'
characters)\&.

.PP

.PP
.SS Exceptions during scanning

.PP

.PP
Scanners may raise the following exceptions when the input cannot be read
according to the format string:
.sp
.sp
\-Raise 
.B Scanf\&.Scan_failure
if the input does not match the format\&.

.sp
\-Raise 
.B Failure
if a conversion to a number is not possible\&.

.sp
\-Raise 
.B End_of_file
if the end of input is encountered while some more
characters are needed to read the current conversion specification\&.

.sp
\-Raise 
.B Invalid_argument
if the format string is invalid\&.

Note:
.sp
.sp
\-as a consequence, scanning a 
.B %s
conversion never raises exception
.B End_of_file
: if the end of input is reached the conversion succeeds and
simply returns the characters read so far, or 
.B ""
if none were ever read\&.

.PP

.PP
.SS Specialised formatted input functions

.PP

.I val sscanf 
: 
.B string -> ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but reads from the given string\&.

.sp

.I val scanf 
: 
.B ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but reads from the predefined formatted input
channel 
.B Scanf\&.Scanning\&.stdin
that is connected to 
.B stdin
\&.

.sp

.I val kscanf 
: 
.B Scanning.in_channel ->
.B   (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but takes an additional function argument
.B ef
that is called in case of error: if the scanning process or
some conversion fails, the scanning function aborts and calls the
error handling function 
.B ef
with the formatted input channel and the
exception that aborted the scanning process as arguments\&.

.sp

.I val ksscanf 
: 
.B string ->
.B   (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.kscanf
but reads from the given string\&.

.sp
.B "Since"
4.02.0

.sp

.PP
.SS Reading format strings from input

.PP

.I val bscanf_format 
: 
.B Scanning.in_channel ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g
.sp

.B bscanf_format ic fmt f
reads a format string token from the formatted
input channel 
.B ic
, according to the given format string 
.B fmt
, and
applies 
.B f
to the resulting format string value\&.
Raise 
.B Scanf\&.Scan_failure
if the format string value read does not have the
same type as 
.B fmt
\&.

.sp
.B "Since"
3.09.0

.sp

.I val sscanf_format 
: 
.B string ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g
.sp
Same as 
.B Scanf\&.bscanf_format
, but reads from the given string\&.

.sp
.B "Since"
3.09.0

.sp

.I val format_from_string 
: 
.B string ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6
.sp

.B format_from_string s fmt
converts a string argument to a format string,
according to the given format string 
.B fmt
\&.
Raise 
.B Scanf\&.Scan_failure
if 
.B s
, considered as a format string, does not
have the same type as 
.B fmt
\&.

.sp
.B "Since"
3.10.0

.sp

.I val unescaped 
: 
.B string -> string
.sp

.B unescaped s
return a copy of 
.B s
with escape sequences (according to
the lexical conventions of OCaml) replaced by their corresponding special
characters\&.
More precisely, 
.B Scanf\&.unescaped
has the following property:
for all string 
.B s
, 
.B Scanf\&.unescaped (String\&.escaped s) = s
\&.
.sp
Always return a copy of the argument, even if there is no escape sequence
in the argument\&.
Raise 
.B Scanf\&.Scan_failure
if 
.B s
is not properly escaped (i\&.e\&. 
.B s
has invalid
escape sequences or special characters that are not properly escaped)\&.
For instance, 
.B Scanf\&.unescaped "\(rs""
will fail\&.

.sp
.B "Since"
4.00.0

.sp

.PP
.SS Deprecated

.PP

.I val fscanf 
: 
.B in_channel -> ('a, 'b, 'c, 'd) scanner
.sp
.B "Deprecated."

.B Scanf\&.fscanf
is error prone and deprecated since 4\&.03\&.0\&.
.sp
This function violates the following invariant of the 
.B Scanf
module:
To preserve scanning semantics, all scanning functions defined in 
.B Scanf
must read from a user defined 
.B Scanf\&.Scanning\&.in_channel
formatted input
channel\&.
.sp
If you need to read from a 
.B in_channel
input channel
.B ic
, simply define a 
.B Scanf\&.Scanning\&.in_channel
formatted input channel as in
.B let ib = Scanning\&.from_channel ic
,
then use 
.B Scanf\&.bscanf ib
as usual\&.

.sp

.I val kfscanf 
: 
.B in_channel ->
.B   (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner
.sp
.B "Deprecated."

.B Scanf\&.kfscanf
is error prone and deprecated since 4\&.03\&.0\&.

.sp
